函数

函数是唯一一种基于特定输入，实现特定任务并可返回任务执行结果的代码块

函数 -> 代码复用

#### 函数声明

```go
func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
  p := newPrinter()
  p.doPrintf(format, a)
  n, err = w.Write(p.buf())
  p.free()
  return
}
```

关键字，函数名，参数列表，返回值列表，函数体

-- 变长参数，变长参数实际上是通过切片来实现的。

--具名返回值（Named Return Value）

--函数声明中的函数体是可选的。如果没有函数体，说明这个函数可能是在 Go 语言之外实现的，比如使用汇编语言实现，然后通过链接器将实现与声明中的函数名链接到一起。没有函数体的函数声明是更高级的话题了，你感兴趣可以自己去了解一下，我们这里还是先打好基础。

函数声明中的函数名其实就是变量名，函数声明中的 func 关键字、参数列表和返回值列表共同构成了**函数类型**。而参数列表与返回值列表的组合也被称为函数签名，它是决定两个函数类型是否相同的决定因素。因此，函数类型也可以看成是由 func 关键字与函数签名组合而成的。

```
// 函数类型
func(io.Writer, string, ...interface{})(int, error)
```

我们可以得到这样一个结论：**每个函数声明所定义的函数，仅仅是对应的函数类型的一个实例**

“函数字面值（Function Literal）”

**匿名函数**

在 Go 中的绝大多数情况，我们还是会通过传统的函数声明来声明一个特定函数类型的实例，也就是我们俗称的“定义一个函数”。

在函数声明阶段，我们把参数列表中的参数叫做形式参数（Parameter，简称形参），在函数体中，我们使用的都是形参；而在函数实际调用时传入的参数被称为实际参数（Argument，简称实参）。

Go 语言中，函数参数传递采用是值传递的方式。所谓“值传递”，就是将实际参数在内存中的表示逐位拷贝（Bitwise Copy）到形式参数中。对于像整型、数组、结构体这类类型，它们的内存表示就是它们自身的数据内容，因此当这些类型作为实参类型时，值传递拷贝的就是它们自身，传递的开销也与它们自身的大小成正比。但是像 string、切片、map 这些类型就不是了，它们的内存表示对应的是它们数据内容的“描述符”。当这些类型作为实参类型时，值传递拷贝的也是它们数据内容的“描述符”，不包括数据内容本身，所以这些类型传递的开销是固定的，与数据内容大小无关。这种只拷贝“描述符”，不拷贝实际数据内容的拷贝过程，也被称为“浅拷贝”。







Go 语言的错误处理机制很大程度就是建立在多返回值的机制之上的，

```go
func foo() {}
func foo() string {}
func foo() (int, string, error) {}
```





