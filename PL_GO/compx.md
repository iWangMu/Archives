都是由多个同构类型（相同类型）或异构类型（不同类型）的元素的值组合而成的。这类数据类型在 Go 语言中被称为复合类型。

Go 语言原生内置了多种复合数据类型，包括数组、切片（slice）、map、结构体，以及像 channel 这类用于并发程序设计的高级复合数据类型。



Go 语言的**数组**是一个长度固定的、由同构类型元素组成的连续序列。

```go
// 数组变量 arr，它的类型为[N]T，其中元素的类型为 T，数组的长度为 N。
var arr [N]T
```

Go 编译器需要在编译阶段就知道数组类型的长度

如果两个数组类型的元素类型 T 与数组长度 N 都是一样的，那么这两个数组类型是等价的，如果有一个属性不同，它们就是两个不同的数组类型。

数组类型不仅是逻辑上的连续序列，而且在实际内存分配时也占据着一整块内存。Go 编译器在为数组类型的变量实际分配内存时，会为 Go 数组分配一整块、可以容纳它所有元素的连续内存，如下图所示：



和基本数据类型一样，我们声明一个数组类型变量的同时，也可以显式地对它进行初始化。如果不进行显式初始化，那么数组中的元素值就是它类型的零值。

当然，我们也可以忽略掉右值初始化表达式中数组类型的长度，用“…”替代，Go 编译器会根据数组元素的个数，自动计算出数组长度

下标赋值的方式对它进行初始化

通过数组类型变量以及下标值，我们可以很容易地访问到数组中的元素值，并且这种访问是十分高效的，不存在 Go 运行时带来的额外开销。但你要记住，数组的下标值是从 0 开始的。

数组类型变量是一个整体，这就意味着一个数组变量表示的是整个数组。这点与 C 语言完全不同，在 C 语言中，数组变量可视为指向数组第一个元素的指针。这样一来，无论是参与迭代，还是作为实际参数传给一个函数 / 方法，Go 传递数组的方式都是纯粹的值拷贝，这会带来较大的内存拷贝开销。---- 切片解决这个问题

Go语言下数组的缺点： 1、元素的个数是固定的，不可变 2、默认只传递值（需要显示指定传递指针），有内存拷贝的开销



切片变量的长度，len(slice)

内置函数 append，我们可以动态地向切片中添加元素。

```go
// runtime/slice.go
type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
```

Go 编译器会自动为每个新创建的切片，建立一个底层数组，默认底层数组的长度与切片初始元素个数相同。我们还可以用以下几种方法创建切片，并指定它底层数组的长度。

make（[]T,len,cap）创建切片

采用 array[low : high : max]语法基于一个已存在的数组创建切片。这种方式被称为数组的切片化

由于切片 sl 的底层数组就是数组 arr，对切片 sl 中元素的修改将直接影响数组 arr 变量。可以说，切片之于数组就像是文件描述符之于文件。这样看来，切片好比打开了一个访问与修改数组的“窗口”

基于切片创建切片。



切片与数组最大的不同，就在于其长度的不定长，这种不定长需要 Go 运行时提供支持，这种支持就是切片的“动态扩容”。